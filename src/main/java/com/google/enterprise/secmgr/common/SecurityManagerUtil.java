// Copyright 2009 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.enterprise.secmgr.common;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Sets;
import com.google.enterprise.logmanager.LogClientParameters;
import com.google.enterprise.util.C;

import org.joda.time.DateTimeUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.util.Formatter;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

import javax.annotation.Nonnegative;
import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.annotation.concurrent.ThreadSafe;

/**
 * Utilities useful throughout the security manager.
 */
@ThreadSafe
@ParametersAreNonnullByDefault
public class SecurityManagerUtil {
  private static final Logger logger = Logger.getLogger(SecurityManagerUtil.class.getName());

  // don't instantiate
  private SecurityManagerUtil() {
    throw new UnsupportedOperationException();
  }

  /**
   * Generate a random nonce as a byte array.
   *
   * @param nBytes The number of random bytes to generate.
   * @return A randomly generated byte array of the given length.
   */
  public static byte[] generateRandomNonce(int nBytes) {
    byte[] randomBytes = new byte[nBytes];
    synchronized (prng) {
      prng.nextBytes(randomBytes);
    }
    return randomBytes;
  }

  /**
   * Generate a random nonce as a hexadecimal string.
   *
   * @param nBytes The number of random bytes to generate.
   * @return A randomly generated hexadecimal string.
   */
  public static String generateRandomNonceHex(int nBytes) {
    return bytesToHex(generateRandomNonce(nBytes));
  }

  private static final SecureRandom prng = new SecureRandom();

  /**
   * Convert a byte array to a hexadecimal string.
   *
   * @param bytes The byte array to convert.
   * @return The equivalent hexadecimal string.
   */
  public static String bytesToHex(byte[] bytes) {
    Formatter f = new Formatter();
    for (byte b : bytes) {
      f.format("%02x", b);
    }
    return f.toString();
  }

  /**
   * Convert a hexadecimal string to a byte array.
   *
   * @param hexString The hexadecimal string to convert.
   * @return The equivalent array of bytes.
   * @throws IllegalArgumentException if the string isn't valid hexadecimal.
   */
  public static byte[] hexToBytes(String hexString) {
    int len = hexString.length();
    Preconditions.checkArgument(len % 2 == 0);
    int nBytes = len / 2;
    byte[] decoded = new byte[nBytes];
    int j = 0;
    for (int i = 0; i < nBytes; i += 1) {
      int d1 = Character.digit(hexString.charAt(j++), 16);
      int d2 = Character.digit(hexString.charAt(j++), 16);
      if (d1 < 0 || d2 < 0) {
        throw new IllegalArgumentException("Non-hexadecimal character in string: " + hexString);
      }
      decoded[i] = (byte) ((d1 << 4) + d2);
    }
    return decoded;
  }

  /**
   * Is a given remote "before" time valid?  In other words, is it possible that
   * the remote "before" time is less than or equal to the remote "now" time?
   *
   * @param before A before time from a remote host.
   * @param now The current time on this host.
   * @return True if the before time might not have passed on the remote host.
   */
  public static boolean isRemoteBeforeTimeValid(long before, long now) {
    return before - CLOCK_SKEW_TIME <= now;
  }

  /**
   * Is a given remote "on or after" time valid?  In other words, is it possible
   * that the remote "on or after" time is greater than the remote "now" time?
   *
   * @param onOrAfter An on-or-after time from a remote host.
   * @param now The current time on this host.
   * @return True if the remote time might have passed on the remote host.
   */
  public static boolean isRemoteOnOrAfterTimeValid(long onOrAfter, long now) {
    return onOrAfter + CLOCK_SKEW_TIME > now;
  }

  @VisibleForTesting
  public static long getClockSkewTime() {
    return CLOCK_SKEW_TIME;
  }

  private static final long CLOCK_SKEW_TIME = 5000;

  /**
   * @return The value of ENT_CONFIG_NAME from the GSA configuration.
   *   If not running on a GSA (e.g. for testing), returns a fixed string.
   */
  public static String getGsaApplianceId() {
    String applianceId = System.getProperty("gsa.applianceid");
    if (Strings.isNullOrEmpty(applianceId)) {
      return "testing";
    }
    return applianceId;
  }

  public static String getConfiguredEntityId() {
    return C.getConfiguredEntityId(System.getProperty("gsa.entityid"), getGsaApplianceId());
  }

  public static long getGsaSessionIdleMillis() {
    String sessionIdleTimeStr = System.getProperty("gsa.sessionidletime");
    long sessionIdleMillis = 0;
    try {
      sessionIdleMillis = Long.parseLong(sessionIdleTimeStr) * 1000;
    } catch (NumberFormatException e) {
      logger.warning("gsa.sessionidletime not correct format.");
    }
    if (sessionIdleMillis <= 0) {
      sessionIdleMillis = DEFAULT_SESSION_IDLE_MILLIS;
    }
    return sessionIdleMillis;
  }

   private static final long DEFAULT_SESSION_IDLE_MILLIS = 30 * 60 * 1000;  // 30 minutes

  /**
   * Sets the LogClientParameters JVM flags based on the System properties passed
   * into Tomcat.
   *
   * The properties expected are:
   *  -Dgsa.enablelogmanager={true|false}
   *  -Dgsa.recordusernames={true|false}
   *  -Dgsa.logmanagerserver={hostname:port}
   */
  public static void initLogClientFlags() {
    String enabled = System.getProperty("gsa.enablelogmanager");
    if (!"true".equals(enabled) && !"false".equals(enabled)) {
      logger.info("gsa.enablelogmanager is set to " + enabled +
          " instead of 'true' or 'false'; skipping config from flags");
    } else {
      LogClientParameters.enableLogManager = Boolean.parseBoolean(enabled);
      logger.info("LogManager enabled is: " + enabled);
    }

    String recordUsernames = System.getProperty("gsa.recordusernames");
    if (!"true".equals(recordUsernames) && !"false".equals(recordUsernames)) {
      logger.info("gsa.recordusernames is set to " + recordUsernames +
          " instead of 'true' or 'false'; skipping config from flags");
    } else {
      LogClientParameters.recordUsernames = Boolean.parseBoolean(recordUsernames);;
      logger.info("LogManager recordUsernames is set to " + recordUsernames);
    }
  }

  public static String getLogManagerServer() {
    String logManServer = System.getProperty("gsa.logmanagerserver");
    return Strings.isNullOrEmpty(logManServer)
        ? LogClientParameters.LOG_MANAGER_SERVER
        : logManServer;
  }

  // TODO: make this configurable (preferably in sec mgr config).
  private static final int THREAD_POOL_SIZE = 40;
  private static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

  @VisibleForTesting
  static int getPrimaryThreadPoolSize() {
    return THREAD_POOL_SIZE;
  }

  /**
   * Runs a bunch of tasks in parallel.
   *
   * @param callables The tasks to be run.
   * @param timeoutMillis The maximum amount of time allowed for processing all
   *     the tasks, in milliseconds.
   * @param decorator A decorator for log messages.
   * @return An immutable list of the computed values, in no particular order.
   *     The number of values is normally the same as the number of tasks, but
   *     if the timeoutMillis is reached or if one or more of the tasks generates an
   *     exception, there will be fewer values than tasks.
   */
  @Nonnull
  public static <T> List<T> runInParallel(
      Iterable<Callable<T>> callables,
      @Nonnegative long timeoutMillis,
      Decorator decorator) throws ExecutionException {
    Preconditions.checkNotNull(callables);
    Preconditions.checkArgument(timeoutMillis >= 0);
    Preconditions.checkNotNull(decorator);

    CompletionService<T> completionService = new ExecutorCompletionService<T>(THREAD_POOL);
    long endTimeMillis = DateTimeUtils.currentTimeMillis() + timeoutMillis;
    Set<Future<T>> futures = Sets.newHashSet();
    ImmutableList.Builder<T> resultsBuilder = ImmutableList.builder();

    try {
      for (Callable<T> callable : callables) {
        futures.add(completionService.submit(callable));
      }
      while (!futures.isEmpty()) {
        Future<T> future
            = completionService.poll(
                endTimeMillis - DateTimeUtils.currentTimeMillis(),
                TimeUnit.MILLISECONDS);
        if (future == null) {
          // timed out, we're done now.
          break;
        }
        try {
          T singleResult = future.get();
          if (null != singleResult) {
            resultsBuilder.add(singleResult);
          }
        } catch (CancellationException e) {
          // Nothing to do but ignore it.
        } finally {
          futures.remove(future);
        }
      }
    } catch (InterruptedException e) {
      // Reset the interrupt, then fall through to the cleanup code below.
      logger.warning(decorator.apply("Timeout in worker thread: " + e.getMessage()));
      Thread.currentThread().interrupt();

    } finally {
      // Cancel any unfinished futures.  Don't wait for them to finish; just
      // move on.  Requests for new threads will, if necessary, block until they
      // have finished.
      for (Future<T> future : futures) {
        future.cancel(true);
      }
    }
    return resultsBuilder.build();
  }

  /**
   * Loads a key store from a given file.
   *
   * @param filename A key store's filename.
   * @param password A password for that file.
   * @return The key store.
   * @throws IOException if there are errors loading the store.
   * @throws GeneralSecurityException if there are security problems with the
   *     store.
   */
  @Nonnull
  public static KeyStore loadKeyStore(String filename, String password)
      throws IOException, GeneralSecurityException {
    return loadKeyStore(FileUtil.getContextFile(filename), password);
  }

  /**
   * Loads a key store from a given file.
   *
   * @param file A key store's file.
   * @param password A password for that file.
   * @return The key store.
   * @throws IOException if there are errors loading the store.
   * @throws GeneralSecurityException if there are security problems with the
   *     store.
   */
  @Nonnull
  public static KeyStore loadKeyStore(File file, String password)
      throws IOException, GeneralSecurityException {
    KeyStore keyStore = KeyStore.getInstance("jks");
    FileInputStream stream = new FileInputStream(file);
    try {
      keyStore.load(stream, password.toCharArray());
    } finally {
      stream.close();
    }
    return keyStore;
  }
}

